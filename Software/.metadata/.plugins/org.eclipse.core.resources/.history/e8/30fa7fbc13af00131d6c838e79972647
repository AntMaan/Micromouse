/*
 * motor.c
 *
 *  Created on: Mar 18, 2014
 *      Author: Anthony Merlino and Brad Ebinger
 */


#include "motor.h"



#define PWM_PIN_OUT(x) 1<<x
#define CALC_CYCLES(us)   (PWM_TIMER_FREQ/1000000)*us
#define CALC_USEC(cycles) (1000000/PWM_TIMER_FREQ)*cycles

void motors_init(void) {

	int i;

	// Set Pins to output/PWM in GPIO
	SysCtlPeripheralEnable(SYSCTL_PERIPH_PWM1);
	SysCtlPWMClockSet(SYSCTL_PWMDIV_64);
	GPIOPinConfigure(GPIO_PF2_M1PWM6);
	GPIOPinConfigure(GPIO_PF3_M1PWM7);
	GPIOPinTypePWM(GPIO_PORTF_BASE, GPIO_PIN_2 | GPIO_PIN_3);

	// Configure the pin for standby control
	GPIOPinTypeGPIOOutput(GPIO_PORTA_BASE, STNDBY);

	// Configure the PWM for each pin:
	// Turn on the generators and set the PW to 0
	// The output is still OFF. Turn on with set_motor_pwm_state
	for (i = 0; i < NUM_MOTORS; i++) {
		PWMGenConfigure(motors[i].pwm_base_module, motors[i].pwm_generator, PWM_GEN_MODE_DOWN | PWM_GEN_MODE_NO_SYNC);
		PWMGenPeriodSet(motors[i].pwm_base_module, motors[i].pwm_generator, CALC_CYCLES(MOTOR_PERIOD));
		PWMPulseWidthSet(motors[i].pwm_base_module, motors[i].pwm_pin, 0);
		PWMGenEnable(motors[i].pwm_base_module, motors[i].pwm_generator);
		GPIOPinTypeGPIOOutput(motors[i].dir_port, motors[i].dir_pins[0] | motors[i].dir_pins[1]);
	}
}

void update_motor(motor_index_t index, motor_direction_t direction, uint16_t duty_tenths_perc){

	switch(direction){
		case CW:
			// Set the pins so that the direction is Clockwise
			GPIOPinWrite(motors[index].dir_port, motors[index].dir_pins[0] | motors[index].dir_pins[1], motors[index].dir_pins[0]);
			break;
		case CCW:
			// Set the pins so that the direction is Counter-Clockwise
			GPIOPinWrite(motors[index].dir_port, motors[index].dir_pins[1] | motors[index].dir_pins[1], motors[index].dir_pins[1]);
			break;
		case BRAKE:
			// Set the pins so that we brake
			GPIOPinWrite(motors[index].dir_port, motors[index].dir_pins[1] | motors[index].dir_pins[1], motors[index].dir_pins[0] | motors[index].dir_pins[1]);
			break;
		case STOP:
			// Set the pins so we stop
			GPIOPinWrite(motors[index].dir_port, motors[index].dir_pins[1] | motors[index].dir_pins[1], 0x00);
			break;
		default:
			break;
	}

	uint32_t usec = MOTOR_PERIOD*duty_tenths_perc/1000;
	set_pulse_width(index, &usec);

}


void set_pulse_width(motor_index_t index, uint32_t *uSec) {
	uint32_t cycles = CALC_CYCLES(*uSec);
	if(cycles > 0xFFFF){
		// Overflow! Set to MAX Value
		cycles = 0xFFFF;
	}

	// set uSec as closest value as possible with Timer settings
	*uSec = CALC_USEC(cycles);

	PWMPulseWidthSet(motors[index].pwm_base_module, motors[index].pwm_pin, cycles);
}

void set_motor_pwm_state(bool isOn) {
	uint32_t pin_mask;
	int i;
	for (i = 0; i < NUM_MOTORS; i++) {
		pin_mask = 1 << (0x0000000F & motors[i].pwm_pin);
		PWMOutputState(motors[i].pwm_base_module, pin_mask, isOn);
	}
}

